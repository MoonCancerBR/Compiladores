from functools import lru_cache

# ---------------------- Parte 1 - Impressão da Árvore ----------------------
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []

def parse_expression(expression):
    def parse(tokens):
        token = tokens.pop(0)
        node = TreeNode(token)
        if tokens and tokens[0] == '(':
            tokens.pop(0)  # remove '('
            while tokens and tokens[0] != ')':
                if tokens[0] == ',':
                    tokens.pop(0)
                    continue
                node.children.append(parse(tokens))
            tokens.pop(0)  # remove ')'
        return node

    def tokenize(expr):
        tokens = []
        current = ""
        for c in expr:
            if c in "(),":
                if current.strip():
                    tokens.append(current.strip())
                    current = ""
                tokens.append(c)
            else:
                current += c
        if current.strip():
            tokens.append(current.strip())
        return tokens

    tokens = tokenize(expression)
    return parse(tokens)

def print_tree(node, prefix="", is_last=True):
    if node is None:
        return
    print(prefix + ("└── " if is_last else "├── ") + node.value)
    prefix += "    " if is_last else "│   "
    for i, child in enumerate(node.children):
        print_tree(child, prefix, i == len(node.children) - 1)

# ---------------- Parte 2 - Seleção de Instruções com PD ----------------
node_map = {}

def get_cost(op):
    if op == "TEMP":
        return 0
    if op == "MOVEM":
        return 2
    return 1

@lru_cache(None)
def cover(node_id):
    node = node_map[node_id]
    custo_filhos = 0
    filhos_info = []
    for child in node.children:
        info = cover(str(id(child)))
        filhos_info.append((info[0], info[1], child))
        custo_filhos += info[0]
    instr = node.value
    total_cost = get_cost(instr) + custo_filhos
    return total_cost, instr, filhos_info

def emit_patterns(node_id):
    _, instr, filhos_info = cover(node_id)
    for _, _, child in filhos_info:
        emit_patterns(str(id(child)))
    print(f"Padrão selecionado: {instr}({', '.join(child.value for _, _, child in filhos_info)})")

# ---------------- Parte 3 - Geração de Código Final ----------------
reg_counter = 1
code_output = []

def emit_code(node_id):
    global reg_counter
    node = node_map[node_id]
    _, instr, filhos_info = cover(node_id)
    regs = [emit_code(str(id(child))) for _, _, child in filhos_info]
    reg_result = f"R{reg_counter}"
    reg_counter += 1

    if instr == "CONST":
        code_output.append(f"MOV {reg_result}, #{node.children[0].value}")
    elif instr == "TEMP":
        code_output.append(f"MOV {reg_result}, TEMP")
    elif instr in {"ADD", "SUB", "MUL", "DIV"}:
        if len(regs) >= 2:
            code_output.append(f"{instr} {reg_result}, {regs[0]}, {regs[1]}")
        else:
            code_output.append(f"{instr} {reg_result}, {', '.join(regs)}")
    elif instr == "MOVEM":
        if len(regs) >= 2:
            code_output.append(f"MOVEM {regs[1]} -> [{regs[0]}]")
        else:
            code_output.append(f"MOVEM ???")  # tratar erro de estrutura
    else:
        code_output.append(f"{instr} {reg_result}")
    return reg_result

# ---------------- Main ----------------
def main():
    global node_map, reg_counter, code_output

    print("Digite a expressão no formato linear (ex: ADD(CONST 1, CONST 2)):")
    expr = input("Expressão: ").strip()
    root = parse_expression(expr)

    print("\nÁrvore de sintaxe da expressão:")
    print_tree(root)

    node_map = {}
    def registrar(node):
        node_map[str(id(node))] = node
        for child in node.children:
            registrar(child)
    registrar(root)

    total_cost, _, _ = cover(str(id(root)))

    print("\nPadrões selecionados:")
    emit_patterns(str(id(root)))

    print("\nCódigo gerado:")
    emit_code(str(id(root)))
    for line in code_output:
        print(line)

    print(f"\nCusto total: {total_cost}")

if __name__ == "__main__":
    main()
